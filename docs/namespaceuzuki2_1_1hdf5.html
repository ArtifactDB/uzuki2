<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uzuki2: uzuki2::hdf5 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">uzuki2
   </div>
   <div id="projectbrief">Recovering R lists faithfully from HDF5 or JSON</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceuzuki2.html">uzuki2</a></li><li class="navelem"><a class="el" href="namespaceuzuki2_1_1hdf5.html">hdf5</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">uzuki2::hdf5 Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Parse an R list from a HDF5 file.  
<a href="namespaceuzuki2_1_1hdf5.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5c598b0c0302e1c2a7d4723dd2ea2f7f"><td class="memTemplParams" colspan="2">template&lt;class Provisioner , class Externals &gt; </td></tr>
<tr class="memitem:a5c598b0c0302e1c2a7d4723dd2ea2f7f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structuzuki2_1_1Base.html">Base</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceuzuki2_1_1hdf5.html#a5c598b0c0302e1c2a7d4723dd2ea2f7f">parse</a> (const H5::Group &amp;handle, const std::string &amp;name, Externals ext)</td></tr>
<tr class="separator:a5c598b0c0302e1c2a7d4723dd2ea2f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bc9082bb2af2dd9bff75379dc3ee15"><td class="memTemplParams" colspan="2">template&lt;class Provisioner &gt; </td></tr>
<tr class="memitem:a39bc9082bb2af2dd9bff75379dc3ee15"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structuzuki2_1_1Base.html">Base</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceuzuki2_1_1hdf5.html#a39bc9082bb2af2dd9bff75379dc3ee15">parse</a> (const H5::Group &amp;handle, const std::string &amp;name)</td></tr>
<tr class="separator:a39bc9082bb2af2dd9bff75379dc3ee15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1568cfcff4d487683ab3ed6ee2d00bc"><td class="memTemplParams" colspan="2">template&lt;class Provisioner , class Externals &gt; </td></tr>
<tr class="memitem:af1568cfcff4d487683ab3ed6ee2d00bc"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structuzuki2_1_1Base.html">Base</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceuzuki2_1_1hdf5.html#af1568cfcff4d487683ab3ed6ee2d00bc">parse</a> (const std::string &amp;file, const std::string &amp;name, Externals ext)</td></tr>
<tr class="separator:af1568cfcff4d487683ab3ed6ee2d00bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cefd1b53c2c22a645fa732c3d498b7"><td class="memTemplParams" colspan="2">template&lt;class Provisioner &gt; </td></tr>
<tr class="memitem:a80cefd1b53c2c22a645fa732c3d498b7"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structuzuki2_1_1Base.html">Base</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceuzuki2_1_1hdf5.html#a80cefd1b53c2c22a645fa732c3d498b7">parse</a> (const std::string &amp;file, const std::string &amp;name)</td></tr>
<tr class="separator:a80cefd1b53c2c22a645fa732c3d498b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5330687aa9572260d194eef4e89966b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuzuki2_1_1hdf5.html#ae5330687aa9572260d194eef4e89966b">validate</a> (const H5::Group &amp;handle, const std::string &amp;name, int num_external=0)</td></tr>
<tr class="separator:ae5330687aa9572260d194eef4e89966b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19a7b6203d50b10bf04868134cc86e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceuzuki2_1_1hdf5.html#af19a7b6203d50b10bf04868134cc86e4">validate</a> (const std::string &amp;file, const std::string &amp;name, int num_external=0)</td></tr>
<tr class="separator:af19a7b6203d50b10bf04868134cc86e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Parse an R list from a HDF5 file. </p>
<p >The hierarchical nature of HDF5 allows it to naturally store nested list structures. It supports random access of list components, which provides some optimization opportunities for parsing large lists. However, it incurs a large overhead per list element; for small lists, users may prefer to use a JSON file instead (see <code>json</code>). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a39bc9082bb2af2dd9bff75379dc3ee15" name="a39bc9082bb2af2dd9bff75379dc3ee15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bc9082bb2af2dd9bff75379dc3ee15">&#9670;&#160;</a></span>parse() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Provisioner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structuzuki2_1_1Base.html">Base</a> &gt; uzuki2::hdf5::parse </td>
          <td>(</td>
          <td class="paramtype">const H5::Group &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Parse HDF5 file contents using the <b><a class="el" href="namespaceuzuki2.html" title="Parse an R list from a HDF5 or JSON file.">uzuki2</a></b> specification, given the group handle. It is assumed that there are no external references.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Provisioner</td><td>A class namespace defining static methods for creating new <code><a class="el" href="structuzuki2_1_1Base.html" title="Base interface for all R objects.">Base</a></code> objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle for a HDF5 group corresponding to the list. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the HDF5 group corresponding to <code>handle</code>. Only used for error messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root <code><a class="el" href="structuzuki2_1_1Base.html" title="Base interface for all R objects.">Base</a></code> object. Depending on <code>Provisioner</code>, this may contain references to all nested objects.</dd></dl>
<p>Any invalid representations in <code>contents</code> will cause an error to be thrown. </p>

</div>
</div>
<a id="a5c598b0c0302e1c2a7d4723dd2ea2f7f" name="a5c598b0c0302e1c2a7d4723dd2ea2f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c598b0c0302e1c2a7d4723dd2ea2f7f">&#9670;&#160;</a></span>parse() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Provisioner , class Externals &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structuzuki2_1_1Base.html">Base</a> &gt; uzuki2::hdf5::parse </td>
          <td>(</td>
          <td class="paramtype">const H5::Group &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Externals&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Provisioner</td><td>A class namespace defining static methods for creating new <code><a class="el" href="structuzuki2_1_1Base.html" title="Base interface for all R objects.">Base</a></code> objects. </td></tr>
    <tr><td class="paramname">Externals</td><td>Class describing how to resolve external references for type <code>EXTERNAL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle for a HDF5 group corresponding to the list. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the HDF5 group corresponding to <code>handle</code>. Only used for error messages. </td></tr>
    <tr><td class="paramname">ext</td><td>Instance of an external reference resolver class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root <code><a class="el" href="structuzuki2_1_1Base.html" title="Base interface for all R objects.">Base</a></code> object. Depending on <code>Provisioner</code>, this may contain references to all nested objects.</dd></dl>
<p>Any invalid representations in <code>contents</code> will cause an error to be thrown.</p>
<h1><a class="anchor" id="provisioner-contract"></a>
Provisioner requirements</h1>
<p >The <code>Provisioner</code> class is expected to provide the following static methods:</p>
<ul>
<li><code>Nothing* new_Nothing()</code>, which returns a new instance of a <code><a class="el" href="structuzuki2_1_1Nothing.html" title="Representation of R&#39;s NULL.">Nothing</a></code> subclass.</li>
<li><code>Other* new_Other(void* p)</code>, which returns a new instance of a <code>Other</code> subclass. <code>p</code> is a pointer to an "external" object, generated by calling <code>ext.get()</code> (see below).</li>
<li><code>List* new_List(size_t l, bool n)</code>, which returns a new instance of a <code><a class="el" href="structuzuki2_1_1List.html" title="Interface for lists.">List</a></code> with length <code>l</code>. If <code>n = true</code>, names are present and will be added via <code><a class="el" href="structuzuki2_1_1List.html#a16d57dcda0cb9c8ffa7724d16473a4ff">List::set_name()</a></code>.</li>
<li><code>IntegerVector* new_Integer(size_t l, bool n, bool s)</code>, which returns a new instance of an <code><a class="el" href="structuzuki2_1_1IntegerVector.html" title="Interface for integer vectors.">IntegerVector</a></code> subclass of length <code>l</code>. If <code>n = true</code>, names are present and will be added via <code><a class="el" href="structuzuki2_1_1Vector.html#a42f996bcbb75853274f004a29fe2da8f">Vector::set_name()</a></code>. If <code>s = true</code> and <code>l = 1</code>, the value was represented on file as a scalar integer.</li>
<li><code>NumberVector* new_Number(size_t l, bool n, bool s)</code>, which returns a new instance of a <code><a class="el" href="structuzuki2_1_1NumberVector.html" title="Interface for a double-precision vector.">NumberVector</a></code> subclass of length <code>l</code>. If <code>n = true</code>, names are present and will be added via <code><a class="el" href="structuzuki2_1_1Vector.html#a42f996bcbb75853274f004a29fe2da8f">Vector::set_name()</a></code>. If <code>s = true</code> and <code>l = 1</code>, the value was represented on file as a scalar float.</li>
<li><code>StringVector* new_String(size_t l, bool n, bool s, StringVector::Format f)</code>, which returns a new instance of a <code><a class="el" href="structuzuki2_1_1StringVector.html" title="Interface for a string vector.">StringVector</a></code> subclass of length <code>l</code> with format <code>f</code>. If <code>n = true</code>, names are present and will be added via <code><a class="el" href="structuzuki2_1_1Vector.html#a42f996bcbb75853274f004a29fe2da8f">Vector::set_name()</a></code>. If <code>s = true</code> and <code>l = 1</code>, the value was represented on file as a scalar string.</li>
<li><code>BooleanVector* new_Boolean(size_t l, bool n, bool s)</code>, which returns a new instance of a <code><a class="el" href="structuzuki2_1_1BooleanVector.html" title="Interface for a boolean vector.">BooleanVector</a></code> subclass of length <code>l</code>. If <code>n = true</code>, names are present and will be added via <code><a class="el" href="structuzuki2_1_1Vector.html#a42f996bcbb75853274f004a29fe2da8f">Vector::set_name()</a></code>. If <code>s = true</code> and <code>l = 1</code>, the value was represented on file as a scalar boolean.</li>
<li><code>Factor* new_Factor(size_t l, bool n, bool s, size_t ll, bool o)</code>, which returns a new instance of a <code><a class="el" href="structuzuki2_1_1Factor.html" title="Interface for a factor.">Factor</a></code> subclass of length <code>l</code> and with <code>ll</code> unique levels. If <code>n = true</code>, names are present and will be added via <code><a class="el" href="structuzuki2_1_1Vector.html#a42f996bcbb75853274f004a29fe2da8f">Vector::set_name()</a></code>. If <code>s = true</code> and <code>l = 1</code>, the lone index was represented on file as a scalar integer. If <code>o = true</code>, the levels should be assumed to be sorted.</li>
</ul>
<h1><a class="anchor" id="external-contract"></a>
Externals requirements</h1>
<p >The <code>Externals</code> class is expected to provide the following <code>const</code> methods:</p>
<ul>
<li><code>void* get(size_t i) const</code>, which returns a pointer to an "external" object, given the index of that object. This will be stored in the corresponding <code>Other</code> subclass generated by <code>Provisioner::new_Other</code>.</li>
<li><code>size_t size()</code>, which returns the number of available external references. </li>
</ul>

</div>
</div>
<a id="a80cefd1b53c2c22a645fa732c3d498b7" name="a80cefd1b53c2c22a645fa732c3d498b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cefd1b53c2c22a645fa732c3d498b7">&#9670;&#160;</a></span>parse() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Provisioner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structuzuki2_1_1Base.html">Base</a> &gt; uzuki2::hdf5::parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Parse HDF5 file contents using the <b><a class="el" href="namespaceuzuki2.html" title="Parse an R list from a HDF5 or JSON file.">uzuki2</a></b> specification, given the file path. It is assumed that there are no external references.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Provisioner</td><td>A class namespace defining static methods for creating new <code><a class="el" href="structuzuki2_1_1Base.html" title="Base interface for all R objects.">Base</a></code> objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Path to a HDF5 file. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the HDF5 group containing the list in <code>file</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root <code><a class="el" href="structuzuki2_1_1Base.html" title="Base interface for all R objects.">Base</a></code> object. Depending on <code>Provisioner</code>, this may contain references to all nested objects.</dd></dl>
<p>Any invalid representations in <code>contents</code> will cause an error to be thrown. </p>

</div>
</div>
<a id="af1568cfcff4d487683ab3ed6ee2d00bc" name="af1568cfcff4d487683ab3ed6ee2d00bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1568cfcff4d487683ab3ed6ee2d00bc">&#9670;&#160;</a></span>parse() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Provisioner , class Externals &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structuzuki2_1_1Base.html">Base</a> &gt; uzuki2::hdf5::parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Externals&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Parse HDF5 file contents using the <b><a class="el" href="namespaceuzuki2.html" title="Parse an R list from a HDF5 or JSON file.">uzuki2</a></b> specification, given the file path.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Provisioner</td><td>A class namespace defining static methods for creating new <code><a class="el" href="structuzuki2_1_1Base.html" title="Base interface for all R objects.">Base</a></code> objects. </td></tr>
    <tr><td class="paramname">Externals</td><td>Class describing how to resolve external references for type <code>EXTERNAL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Path to a HDF5 file. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the HDF5 group containing the list in <code>file</code>. </td></tr>
    <tr><td class="paramname">ext</td><td>Instance of an external reference resolver class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root <code><a class="el" href="structuzuki2_1_1Base.html" title="Base interface for all R objects.">Base</a></code> object. Depending on <code>Provisioner</code>, this may contain references to all nested objects.</dd></dl>
<p>Any invalid representations in <code>contents</code> will cause an error to be thrown. </p>

</div>
</div>
<a id="ae5330687aa9572260d194eef4e89966b" name="ae5330687aa9572260d194eef4e89966b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5330687aa9572260d194eef4e89966b">&#9670;&#160;</a></span>validate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uzuki2::hdf5::validate </td>
          <td>(</td>
          <td class="paramtype">const H5::Group &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_external</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Validate HDF5 file contents against the <b><a class="el" href="namespaceuzuki2.html" title="Parse an R list from a HDF5 or JSON file.">uzuki2</a></b> specification, given the group handle. Any invalid representations will cause an error to be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle for a HDF5 group corresponding to the list. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the HDF5 group corresponding to <code>handle</code>. Only used for error messages. </td></tr>
    <tr><td class="paramname">num_external</td><td>Expected number of external references. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af19a7b6203d50b10bf04868134cc86e4" name="af19a7b6203d50b10bf04868134cc86e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19a7b6203d50b10bf04868134cc86e4">&#9670;&#160;</a></span>validate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uzuki2::hdf5::validate </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_external</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Validate HDF5 file contents against the <b><a class="el" href="namespaceuzuki2.html" title="Parse an R list from a HDF5 or JSON file.">uzuki2</a></b> specification, given the file path. Any invalid representations will cause an error to be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Path to a HDF5 file. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the HDF5 group containing the list in <code>file</code>. </td></tr>
    <tr><td class="paramname">num_external</td><td>Expected number of external references. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
